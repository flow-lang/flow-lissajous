{"version":3,"sources":["runtime/virtual-audio.js","utils.js","runtime/virtual-dom.js","program/instrument.js","program/effect.js","program/index.js"],"names":["defer","f","setTimeout","AudioContext","window","webkitAudioContext","VirtualAudioGraph","context","opts","$context","$nodes","$","createGain","gain","linearRampToValueAtTime","currentTime","connect","destination","vPrev","autostart","resume","flatten","graph","nodes","depth","forEach","node","i","type","key","connections","base","length","oldNodes","newNodes","Object","patches","created","updated","removed","newNode","oldNode","push","data","connection","split","j","Math","max","properties","oldProp","newProp","label","value","oldConnection","newConnection","values","vGraph","vCurr","prepare","diff","patch","_destroyNode","_removeProperty","_disconnect","_createNode","_setProperty","_connect","suspend","$node","createAnalyser","createBufferSource","createBiquadFilter","createChannelMerger","createChannelSplitter","createConstantSource","createConvolver","maxDelayTime","find","createDelay","createDynamicsCompressor","feedforward","feedback","createIIRFilter","mediaElement","createMediaElementSource","document","querySelector","createMediaStreamDestination","createOscillator","createPanner","createStereoPanner","createWaveShaper","console","warn","prop","start","stop","disconnect","method","target","time","default","a","b","param","VirtualDOM","$root","firstChild","removeChild","attrs","children","index","$el","childNodes","_replace","isText","isVirtualNode","tag","prevAttr","currAttr","setAttribute","name","removeAttribute","update","isComponent","_remove","_append","createTextNode","createElement","attr","elem","appendChild","_create","replaceChild","remove","instrument","init","$model","$audio","$view","audio","view","listen","__init","__update","__audio","__view","__listen","DEBUG_MODE","$plugins","html","event","$dispatch","action","result","Array","isArray","$update","model","effect","undefined","group","JSON","stringify","timeEnd","dom","events","plugin","filter","__eventType","run","groupEnd","use","log","__pluginName","__pluginType","__registerPlugin","root","flags","pluginType","debug","__install","send","none","batch","effects"],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["const defer = f => setTimeout(f, 0)\nconst AudioContext = window.AudioContext || window.webkitAudioContext\n\nexport default class VirtualAudioGraph {\n  // Static Methods ============================================================\n  //\n  static prepare (graph = []) {\n    // The first step in preparing the graph is to key each virtual node.\n    // This is how we perform a diff between graphs and calculate what has\n    // changed each update.\n    const key = (graph, base = '') => {\n      graph.forEach((node, i) => {\n        // RefNodes always have a key, and they also\n        // cannot have connections or properties\n        // so we can just return early and move on.\n        if (node.type === 'RefNode') return\n        // Assign the node a key if it didn't already have one.\n        // This is how we track changes to the graph in a slightly\n        // more organised way\n        if (!node.key) node.key = `${base}_${i}`\n\n        // Recursively assign keys to this nodes connections.\n        if (node.connections && node.connections.length > 0) {\n          key(node.connections, node.key)\n        }\n      })\n\n      return graph\n    }\n\n    // It is often most natural to represent the audio graph as a list\n    // of trees, using RefNodes to \"jump\" between chains of node\n    // connections. This isns't the easiest data structure to deal with\n    // however, so the next step in preparation is the flatten the graph\n    // into a single array.\n    const flatten = (graph, nodes = {}, depth = 0) => {\n      graph.forEach((node, i) => {\n        // Don't push RefNodes to the flat graph.\n        if (node.type !== 'RefNode') nodes[node.key] = node\n        if (node.connections) flatten(node.connections, nodes, depth + 1)\n        // If we're deeper than the root of the graph, replace\n        // this node with a reference to itself by key.\n        if (depth > 0) graph[i] = { type: 'RefNode', key: node.key }\n      })\n\n      return nodes\n    }\n\n    return flatten(key(graph))\n  }\n\n  //\n  static diff (oldNodes, newNodes) {\n    const patches = { created: [], updated: [], removed: [] }\n\n    for (const newNode of Object.values(newNodes)) {\n      const oldNode = oldNodes[newNode.key]\n\n      // A node with newNode.key does not exist in the old graph, so this must\n      // mean we've created a brand new node.\n      if (!oldNode) {\n        patches.created.push({ type: 'node', key: newNode.key, data: newNode })\n\n        newNode.connections.forEach(connection => {\n          patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\n        })\n\n      // A node with the same key exists in both graphs, but the type has changed\n      // (eg osc -> gain) so we need to recreate the node.\n      } else if (oldNode.type !== newNode.type) {\n        patches.updated.push({ type: 'node', key: newNode.key, data: newNode })\n\n        newNode.connections.forEach(connection => {\n          patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\n        })\n\n      // A node with the same key exists in both graphs and the node hasn't\n      // fundamentally changed, so now we check whether properties or connections\n      // have changed.\n      } else {\n        // Checking properties...\n        for (let j = 0; j < Math.max(oldNode.properties.length, newNode.properties.length); j++) {\n          const oldProp = oldNode.properties[j]\n          const newProp = newNode.properties[j]\n\n          //\n          if (!oldProp) {\n            patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\n          } else if (!newProp) {\n            patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\n          } else if (oldProp.label !== newProp.label) {\n            patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\n            patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\n          } else if (oldProp.value !== newProp.value) {\n            patches.updated.push({ type: 'property', key: oldNode.key, data: newProp })\n          }\n        }\n\n        // Checking connections...\n        for (let j = 0; j < Math.max(oldNode.connections.length, newNode.connections.length); j++) {\n          const oldConnection = oldNode.connections[j]\n          const newConnection = newNode.connections[j]\n\n          //\n          if (!oldConnection) {\n            patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\n          } else if (!newConnection) {\n            patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\n          } else if (oldConnection.key !== newConnection.key) {\n            patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\n            patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\n          }\n        }\n      }\n\n      delete oldNodes[newNode.key]\n    }\n\n    for (const oldNode of Object.values(oldNodes)) {\n      patches.removed.push({ type: 'node', key: oldNode.key, data: oldNode })\n    }\n\n    return patches\n  }\n\n  // Constructor ===============================================================\n  //\n  constructor (context = new AudioContext(), opts = {}) {\n    // Borrowing a convetion from virtual dom libraries, the $ sign //is used to\n    // indicate \"real\" Web Audio bits, and the v- prefix is used to indicate\n    // virtual elements.\n\n    // $context is a reference to the `AudioContext` either passed in or created\n    // on construction.\n    this.$context = context\n    // A reference to the real graph of audio nodes\n    this.$nodes = {\n      $: this.$context.createGain()\n    }\n\n    // Schedule the master gain to fade in as soon as the audio context is \n    // resumed (if it was suspended) or immediately (if the context was created)\n    // in response to some user action.\n    this.$nodes.$.gain.linearRampToValueAtTime(1, this.$context.currentTime + 1)\n    this.$nodes.$.connect(this.$context.destination)\n\n    // We keep track of the prebious graph so we can perform a diff and work out\n    // what has changed between updates.\n    this.vPrev = {}\n\n    // In most modern browsers an Audio Context starts in a suspended state and\n    // requires some user interaction before it can be resumed. Still, we can\n    // attempt to resume the context ourselves in the developer passes in the\n    // `autostart` option.\n    if (opts.autostart) this.resume()\n  }\n\n  // Public Methods ============================================================\n  //\n  update (vGraph = []) {\n    // The accompanying library of virtual node functions\n    // encourages a nested tree-like approach to describing\n    // audio graphs. This isn't the easiest structure to deal\n    // with, however, so a preparation step serves to wrestle\n    // the graph into a more suitable shape.\n    const vCurr = VirtualAudioGraph.prepare(vGraph)\n\n    // A diff tracks everything that has been removed, created,\n    // and updated between updates. We perform this step so we\n    // only touch the audio nodes that need to be changed in some\n    // way.\n    const diff = VirtualAudioGraph.diff(this.vPrev, vCurr)\n\n    // Remove nodes and properties from the graph.\n    diff.removed.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._destroyNode(patch.key)\n          break\n        case 'property':\n          this._removeProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          this._disconnect(patch.key, patch.data)\n          break\n      }\n    })\n\n    // Create new nodes and add new properties to\n    // the graph.\n    diff.created.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._createNode(patch.key, patch.data)\n          break\n        case 'property':\n          this._setProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          defer(() => this._connect(patch.key, patch.data))\n          break\n      }\n    })\n\n    // Update existing nodes and properties in the\n    // graph.\n    diff.updated.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._destroyNode(patch.key)\n          this._createNode(patch.key, patch.data)\n          break\n        case 'property':\n          this._setProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          // Connections can't be updated\n          break\n      }\n    })\n\n    // Store the current graph for next time.\n    this.vPrev = vCurr\n  }\n\n  // A thin wrapper of the `AudioContext.suspend()` method. This\n  // bassically exists so developers don't have to reach in and\n  // touch the \"real\" audio context directly.\n  suspend () {\n    this.$nodes.$.gain.value = 0\n    this.$context.suspend()\n  }\n\n  // A thin wrapper of the `AudioContext.resume()` method. This\n  // bassically exists so developers don't have to reach in and\n  // touch the \"real\" audio context directly.\n  resume () {\n    this.$context.resume()\n    this.$nodes.$.gain.linearRampToValueAtTime(1, this.$context.currentTime + 0.1)\n  }\n\n  // Private Methods ===========================================================\n  //\n  _createNode (key, { type, properties }) {\n    let $node = null\n\n    //\n    switch (type) {\n      case 'AnalyserNode':\n        $node = this.$context.createAnalyser()\n        break\n      case 'AudioBufferSourceNode':\n        $node = this.$context.createBufferSource()\n        break\n      case 'AudioDestinationNode':\n        $node = this.$nodes.$\n        break\n      case 'BiquadFilterNode':\n        $node = this.$context.createBiquadFilter()\n        break\n      case 'ChannelMergerNode':\n        $node = this.$context.createChannelMerger()\n        break\n      case 'ChannelSplitterNode':\n        $node = this.$context.createChannelSplitter()\n        break\n      case 'ConstantSourceNode':\n        $node = this.$context.createConstantSource()\n        break\n      case 'ConvolverNode':\n        $node = this.$context.createConvolver()\n        break\n      case 'DelayNode':\n        const maxDelayTime = properties.find(({ label }) => label === 'maxDelayTime')\n        $node = this.$context.createDelay((maxDelayTime && maxDelayTime.value) || 1)\n        break\n      case 'DynamicsCompressorNode':\n        $node = this.$context.createDynamicsCompressor()\n        break\n      case 'GainNode':\n        $node = this.$context.createGain()\n        break\n      case 'IIRFilterNode':\n        const feedforward = properties.find(({ label }) => label === 'feedforward')\n        const feedback = properties.find(({ label }) => label === 'feedback')\n        $node = this.$context.createIIRFilter(\n          (feedforward && feedforward.value) || [0],\n          (feedback && feedback.value) || [1]\n        )\n        break\n      case 'MediaElementAudioSourceNode':\n        const mediaElement = properties.find(({ label }) => label === 'mediaElement')\n        $node = this.$context.createMediaElementSource(\n          document.querySelector(mediaElement.value)\n        )\n        break\n      case 'MediaStreamAudioDestinationNode':\n        $node = this.$context.createMediaStreamDestination()\n        break\n        // TODO: How should I handle creating / grabbing the media stream?\n        // case 'MediaStreamAudioSourceNode':\n        //   $node = this.$context.createMediaStreamSource(\n\n        //   )\n        //   break\n      case 'OscillatorNode':\n        $node = this.$context.createOscillator()\n        break\n      case 'PannerNode':\n        $node = this.$context.createPanner()\n        break\n      case 'StereoPannerNode':\n        $node = this.$context.createStereoPanner()\n        break\n      case 'WaveShaperNode':\n        $node = this.$context.createWaveShaper()\n        break\n      //\n      default:\n        console.warn(`Invalide node type of: ${type}. Defaulting to GainNode to avoid crashing the AudioContext.`)\n        $node = this.$context.createGain()\n    }\n\n    this.$nodes[key] = $node\n\n    //\n    properties.forEach(prop => this._setProperty(key, prop))\n\n    // Certain nodes like oscillators must be started before they will produce\n    // noise. We make the assumption that these nodes should always start\n    // immediately after they have been created, so if a `start` method exists we\n    // call it.\n    if ($node.start) $node.start()\n  }\n\n  //\n  _destroyNode (key) {\n    const $node = this.$nodes[key]\n\n    // Certain nodes like oscillators can be stopped. It probably doesn't make\n    // much of a difference calling this method, but we do just in case!\n    if ($node.stop) $node.stop()\n\n    // Calling disconnect with no arguments will disconnect this node from\n    // everything.\n    $node.disconnect()\n\n    // Finally remove the node from the graph and let the GC do its job.\n    delete this.$nodes[key]\n  }\n\n  //\n  _setProperty (key, { type, label, value }) {\n    const $node = this.$nodes[key]\n\n    switch (type) {\n      case 'NodeProperty':\n        $node[label] = value\n        break\n      case 'AudioParam':\n        $node[label].linearRampToValueAtTime(value, this.$context.currentTime + 0.05)\n        break\n      case 'ScheduledAudioParam':\n        $node[label][value.method](value.target, value.time)\n        break\n    }\n  }\n\n  //\n  _removeProperty (key, { type, label, value }) {\n    const $node = this.$nodes[key]\n\n    switch (type) {\n      case 'NodeProperty':\n        break\n      case 'AudioParam':\n        $node[label].value = $node[label].linearRampToValueAtTime($node[label].default, this.$context.currentTime + 0.05)\n        break\n      case 'ScheduledAudioParam':\n        // TODO: work out how to cancel scheduled updates\n        break\n    }\n  }\n\n  //\n  _connect (a, [b, param = null]) {\n    if (b) this.$nodes[a].connect(param ? this.$nodes[b][param] : this.$nodes[b])\n  }\n\n  //\n  _disconnect (a, [b, param = null]) {\n    if (b) this.$nodes[a].disconnect(param ? this.$nodes[b][param] : this.$nodes[b])\n  }\n}","// Defer pushes a function to the back of the Browser's event queue. It essentially\n// tells the browser to \"do f when you next have time.\"\nexport const defer = f => setTimeout(f, 0)\n","import { defer } from '../utils'\n\nexport default class VirtualDOM {\n  // Static Methods ============================================================\n  //\n  static isText (node) {\n    return typeof node === 'string' ||\n      typeof node === 'number' ||\n      typeof node === 'boolean'\n  }\n\n  //\n  static isVirtualNode (node) {\n    return typeof node === 'object' && node.attrs && node.children\n  }\n\n  //\n  static isComponent (node) {\n    return typeof node === 'function'\n  }\n\n  // Constructor ===============================================================\n  //\n  constructor ($root) {\n    this.$root = $root\n    this.vPrev = null\n\n    // Remove any children on the root DOM node when a new VDOM is created, this\n    // ensures nothing interferes with the diffing process.\n    while (this.$root.firstChild) {\n      this.$root.removeChild(this.$root.firstChild)\n    }\n  }\n\n  // Public Methods ============================================================\n  //\n  update (vCurr, vPrev, $root, index = 0) {\n    // When update is first called it is just given the new virtual tree to diff,\n    // but it is then called recursively on each child element with the appropriate\n    // previous tree and root node. Because of this, we default to the original\n    // previous tree and the global root DOM node. We don't use the default\n    // assignment in the function arguments (like with index = 0) because I don't\n    // think you can access `this` from function arguments.\n    vPrev = vPrev || this.vPrev\n    $root = $root || this.$root\n\n    const $el = $root.childNodes[index]\n\n    // There is no previous tree.\n    if (!vPrev || !$el) {\n      this._append($root, vCurr)\n\n    // There is no new tree. This probably means we've\n    // removed a node (or the entire tree) from the previous\n    // tree so let's remove it from the dom.\n    } else if (!vCurr) {\n      $el && this._remove($el)\n\n    // There is a type mismatch between the previous and current\n    // trees. For example the old tree was an object representing\n    // a dom node, and now it is a string representing a text node.\n    } else if (typeof vPrev !== typeof vCurr) {\n      this._replace($root, $el, vCurr)\n\n    // The current nodes are the same type AND they are both text-like.\n    // This means we can do a simple equality comparison and replace\n    // them if necessary.\n    } else if (VirtualDOM.isText(vPrev) && VirtualDOM.isText(vCurr)) {\n      if (vPrev !== vCurr) {\n        this._replace($root, $el, vCurr)\n      }\n\n    // The current nodes are the same type AND they are both virtual nodes.\n    // Here we perform a more involved diff to determine what and how\n    // to update.\n    } else if (VirtualDOM.isVirtualNode(vPrev) && VirtualDOM.isVirtualNode(vCurr)) {\n      // We can safely assume if the tag has changed that the overall\n      // structure of the sub tree has changed too, and so we can\n      // replace the node and its children without performing any further\n      // diff.\n      if (vPrev.tag !== vCurr.tag) {\n        this._replace($root, $el, vCurr)\n\n      // Otherwise...\n      } else {\n        // First we diff the attributes on the node.\n        for (let i = 0; i < vPrev.attrs.length || i < vCurr.attrs.length; i++) {\n          const prevAttr = vPrev.attrs[i]\n          const currAttr = vCurr.attrs[i]\n\n          // This is somewhat ineffecient. If the order of attributes\n          // is different but both the previous and current node has\n          // the same attributes, they will be removed and then re-added.\n          if (!currAttr) {\n            $el.removeAttribute(prevAttr.name)\n          } else {\n            $el.setAttribute(currAttr.name, currAttr.value)\n          }\n        }\n      }\n\n      // Then iterate each of this node's children and recursively call\n      // the render function.\n      for (let i = 0; i < Math.max(vPrev.children.length, vCurr.children.length); i++) {\n        this.update(vCurr.children[i], vPrev.children[i], $el, i)\n      }\n\n    // Components are functions that return some virtual dom node(s), so they\n    // need to be handled differently. Currently we don't actually support\n    // components, but this is the foundation to do so.\n    } else if (VirtualDOM.isComponent(vPrev) && VirtualDOM.isComponent(vCurr)) {\n\n    }\n\n    // Update the previous tree so we can perform the right diff on subsequent\n    // calls to update.\n    this.vPrev = vCurr\n  }\n\n  // Private Methods ===========================================================\n  //\n  _create (node) {\n    if (VirtualDOM.isText(node)) {\n      return document.createTextNode(`${node}`)\n    }\n\n    // VirtualDOM.isVirtualNode performs the necessary checks to make sure the\n    // object has the necessary fields (type, attrs, children) so we can safely\n    // assume everything exists if it passes that check.\n    if (VirtualDOM.isVirtualNode(node)) {\n      // We assume the tag is valid, some checks\n      // may be useful here...\n      const $el = document.createElement(node.tag)\n\n      for (const attr of node.attrs) {\n        $el.setAttribute(attr.name, attr.value)\n      }\n\n      // Recursively create all the children\n      // of this node\n      for (const elem of node.children) {\n        $el.appendChild(this._create(elem))\n      }\n\n      return $el\n    }\n\n    // In the future we might want to handle custom omponent functions, but\n    // ight now we just return an empty node.\n    if (VirtualDOM.isComponent(node)) {\n      return document.createTextNode('')\n    }\n\n    // If some invalid object was passed in, just create a blank DOM node.\n    return document.createTextNode('')\n  }\n\n  //\n  _replace ($root, $el, node) {\n    $root.replaceChild(this._create(node), $el)\n  }\n\n  //\n  _append ($root, node) {\n    $root.appendChild(this._create(node))\n  }\n\n  //\n  _remove ($el) {\n    defer(() => $el.remove())\n  }\n}\n","import VirtualAudioGraph from '../runtime/virtual-audio'\nimport VirtualDOM from '../runtime/virtual-dom'\n\nimport { defer } from '../utils'\n\nexport default function instrument ({ init, update, audio, view, listen }) {\n  const __init = init\n  const __update = update\n  const __audio = audio\n  const __view = view\n  const __listen = listen\n\n  // Debug mode prints a load of information to the console at every step of\n  // the programs lifecycle. Generally not recommended as this is going to\n  // really hurt performance. Useful to see which part of your program is a\n  // bottleneck though.\n  let DEBUG_MODE = false\n\n  // Plugins can be registered to include new audio nodes, HTML components or\n  // different event listeners, so let's keep track of all the plugins a dev\n  // has added.\n  let $plugins = {\n    audio: [],\n    html: [],\n    event: []\n  }\n\n  let $context // An instance of an AudioContext\n  let $root // The root DOM node to attach our view to\n\n  let $model // To complete state of our program\n\n  let $audio // The VirtualAudioGraph\n  let $view // The VirtualDOM\n\n  // $dispatch is how side side effects,  events, and calls to send() can update\n  // the model.\n  const $dispatch = action => defer(() => {\n    const result = __update(action, $model)\n\n    // When we need to invoke additional side effects, calls to __update can\n    // reutrn an array like [ model, sideEffect ]. It's tedious to wrap every\n    // new model in an array if we don't need effects, however, so we allow\n    // __update to return anything. Anything that isn't an array is treated\n    // like a new model and wrapped here.\n    Array.isArray(result) ? $update(result) : $update([ result ])\n  })\n\n  // The internal update function. This takes the result of the users __update\n  // function and takes care of turning that new model into a new audio graph,\n  // dom, and event listeners. This is also where Effects get called.\n  const $update = ([ model, effect = undefined ]) => {\n    /* DEBUG STATEMENT */ if (DEBUG_MODE) console.time('Total update time')\n    /* DEBUG STATEMENT */ if (DEBUG_MODE) console.group('$update')\n\n    // If the model supplied is invalid, show a warning in the console to let\n    // the developer know. We don't do a simple falsey check (!model) because\n    // its reasnoable for a simple model to be an empty string or 0.\n    if (typeof model === 'undefined' || model === null) {\n      console.warn('Your update function returned undefined or null, ' +\n        'the model will remain unchainged. ' +\n        'Did you forget to handle all of your Actions?'\n      )\n\n    // A fairly naive check to see if the model has changed between updates. There\n    // is probably a performance cost to calling JSON.stringify like this, but it's\n    // potentially quicker than generating new virtual audio graphs, dom trees, and\n    // event listeners just to diff something that hasn't changed.\n    } else if (JSON.stringify($model) !== JSON.stringify(model)) {\n      $model = model\n\n      // Audio -----------------------------------------------------------------\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.time('$audio')\n      const graph = __audio($model)\n\n      $audio.update(graph)\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.timeEnd('$audio')\n      // DOM -------------------------------------------------------------------\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.time('$view')\n      const dom = __view($model)\n\n      $view.update(dom)\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.timeEnd('$view')\n      // Events ----------------------------------------------------------------\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.time('$events')\n      const events = __listen($model)\n\n      // Each plugin creates events with its own __eventType property. So for each\n      // plugin, filter the events list and only pass in the ones that plugin was\n      // designed to handle.\n      $plugins.event.forEach(plugin => {\n        plugin.__update(\n          events.filter(event =>\n            event.__eventType === plugin.__eventType\n          )\n        )\n      })\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.timeEnd('$events')\n    }\n\n    // Effects are functions that can have side effects, or do stateful things.\n    // to return an action back to the runtime they receive the $dispatch function.\n    if (effect) {\n      if (typeof effect === 'object') {\n        effect.run($dispatch, $model)\n      } else {\n        effect($dispatch, $model)\n      }\n    }\n\n    /* DEBUG STATEMENT */ if (DEBUG_MODE) console.groupEnd('$update')\n    /* DEBUG STATEMENT */ if (DEBUG_MODE) console.timeEnd('Total update time')\n  }\n\n  const __registerPlugin = plugin => {\n    switch (plugin.__pluginType) {\n      case 'audio':\n        break\n      case 'html':\n        break\n      case 'event':\n        $plugins.event.push(plugin)\n        break\n    }\n  }\n\n  return {\n    // Before a Program has been started, plugins can be registered to expand\n    // its functionality. They get installed when the start method is called\n    // so new plugins can't be registered after that.\n    use (plugin) {\n      console.log(`Registering ${plugin.__pluginName} plugin.`)\n      __registerPlugin(plugin)\n    },\n\n    // Creating a new Program isn't enough, it must be started before anything can\n    // happen. Calling start will setup the virtual audio graph and virtual DOM with\n    // their context and root node respectively. It'll also install any plugins that\n    // were registered prior to calling start, before finally creating the first model\n    // and performing the first render.\n    start ({ context, root, flags }) {\n      DEBUG_MODE = flags && flags.debug || DEBUG_MODE\n\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.log('Starting Program...')\n      $context = context\n      $root = root\n\n      $audio = new VirtualAudioGraph($context)\n      $view = new VirtualDOM($root)\n\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.log('Installing plugins...')\n      for (const pluginType in $plugins) {\n        $plugins[pluginType].forEach(plugin => {\n          /* DEBUG STATEMENT */ if (DEBUG_MODE) console.log(`Installing ${plugin.__pluginName} plugin.`)\n          plugin.__install({ $context, $root, $dispatch })\n        })\n      }\n\n      /* DEBUG STATEMENT */ if (DEBUG_MODE) console.log('Running initial update...')\n      $update([ __init(flags, $context.currentTime, $root) ])\n    },\n\n    // Use this to send an Action to the runtime from some external javascript.\n    send (action) {\n      $dispatch(action)\n    }\n  }\n}\n","export const none = () => {}\nexport const batch = (...effects) => ($dispatch, $model) =>\n  (effects || []).forEach(effect => effect($dispatch, $model))\n\nexport default {\n  none,\n  batch\n}","export { default as instrument } from './instrument'\nexport { default as effect } from './effect'"]}