{"version":3,"sources":["runtime/virtual-audio.js"],"names":["defer","f","setTimeout","AudioContext","window","webkitAudioContext","VirtualAudioGraph","context","opts","$context","$nodes","$","createGain","gain","linearRampToValueAtTime","currentTime","connect","destination","vPrev","autostart","resume","flatten","graph","nodes","depth","forEach","node","i","type","key","connections","base","length","oldNodes","newNodes","Object","patches","created","updated","removed","newNode","oldNode","push","data","connection","split","j","Math","max","properties","oldProp","newProp","label","value","oldConnection","newConnection","values","vGraph","vCurr","prepare","diff","patch","_destroyNode","_removeProperty","_disconnect","_createNode","_setProperty","_connect","suspend","$node","createAnalyser","createBufferSource","createBiquadFilter","createChannelMerger","createChannelSplitter","createConstantSource","createConvolver","maxDelayTime","find","createDelay","createDynamicsCompressor","feedforward","feedback","createIIRFilter","mediaElement","createMediaElementSource","document","querySelector","createMediaStreamDestination","createOscillator","createPanner","createStereoPanner","createWaveShaper","console","warn","prop","start","stop","disconnect","method","target","time","default","a","b","param"],"mappings":"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","file":"virtual-audio.js","sourceRoot":"../src","sourcesContent":["const defer = f => setTimeout(f, 0)\nconst AudioContext = window.AudioContext || window.webkitAudioContext\n\nexport default class VirtualAudioGraph {\n  // Static Methods ============================================================\n  //\n  static prepare (graph = []) {\n    // The first step in preparing the graph is to key each virtual node.\n    // This is how we perform a diff between graphs and calculate what has\n    // changed each update.\n    const key = (graph, base = '') => {\n      graph.forEach((node, i) => {\n        // RefNodes always have a key, and they also\n        // cannot have connections or properties\n        // so we can just return early and move on.\n        if (node.type === 'RefNode') return\n        // Assign the node a key if it didn't already have one.\n        // This is how we track changes to the graph in a slightly\n        // more organised way\n        if (!node.key) node.key = `${base}_${i}`\n\n        // Recursively assign keys to this nodes connections.\n        if (node.connections && node.connections.length > 0) {\n          key(node.connections, node.key)\n        }\n      })\n\n      return graph\n    }\n\n    // It is often most natural to represent the audio graph as a list\n    // of trees, using RefNodes to \"jump\" between chains of node\n    // connections. This isns't the easiest data structure to deal with\n    // however, so the next step in preparation is the flatten the graph\n    // into a single array.\n    const flatten = (graph, nodes = {}, depth = 0) => {\n      graph.forEach((node, i) => {\n        // Don't push RefNodes to the flat graph.\n        if (node.type !== 'RefNode') nodes[node.key] = node\n        if (node.connections) flatten(node.connections, nodes, depth + 1)\n        // If we're deeper than the root of the graph, replace\n        // this node with a reference to itself by key.\n        if (depth > 0) graph[i] = { type: 'RefNode', key: node.key }\n      })\n\n      return nodes\n    }\n\n    return flatten(key(graph))\n  }\n\n  //\n  static diff (oldNodes, newNodes) {\n    const patches = { created: [], updated: [], removed: [] }\n\n    for (const newNode of Object.values(newNodes)) {\n      const oldNode = oldNodes[newNode.key]\n\n      // A node with newNode.key does not exist in the old graph, so this must\n      // mean we've created a brand new node.\n      if (!oldNode) {\n        patches.created.push({ type: 'node', key: newNode.key, data: newNode })\n\n        newNode.connections.forEach(connection => {\n          patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\n        })\n\n      // A node with the same key exists in both graphs, but the type has changed\n      // (eg osc -> gain) so we need to recreate the node.\n      } else if (oldNode.type !== newNode.type) {\n        patches.updated.push({ type: 'node', key: newNode.key, data: newNode })\n\n        newNode.connections.forEach(connection => {\n          patches.created.push({ type: 'connection', key: newNode.key, data: connection.key.split('.') })\n        })\n\n      // A node with the same key exists in both graphs and the node hasn't\n      // fundamentally changed, so now we check whether properties or connections\n      // have changed.\n      } else {\n        // Checking properties...\n        for (let j = 0; j < Math.max(oldNode.properties.length, newNode.properties.length); j++) {\n          const oldProp = oldNode.properties[j]\n          const newProp = newNode.properties[j]\n\n          //\n          if (!oldProp) {\n            patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\n          } else if (!newProp) {\n            patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\n          } else if (oldProp.label !== newProp.label) {\n            patches.removed.push({ type: 'property', key: oldNode.key, data: oldProp })\n            patches.created.push({ type: 'property', key: oldNode.key, data: newProp })\n          } else if (oldProp.value !== newProp.value) {\n            patches.updated.push({ type: 'property', key: oldNode.key, data: newProp })\n          }\n        }\n\n        // Checking connections...\n        for (let j = 0; j < Math.max(oldNode.connections.length, newNode.connections.length); j++) {\n          const oldConnection = oldNode.connections[j]\n          const newConnection = newNode.connections[j]\n\n          //\n          if (!oldConnection) {\n            patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\n          } else if (!newConnection) {\n            patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\n          } else if (oldConnection.key !== newConnection.key) {\n            patches.removed.push({ type: 'connection', key: oldNode.key, data: oldConnection.key.split('.') })\n            patches.created.push({ type: 'connection', key: oldNode.key, data: newConnection.key.split('.') })\n          }\n        }\n      }\n\n      delete oldNodes[newNode.key]\n    }\n\n    for (const oldNode of Object.values(oldNodes)) {\n      patches.removed.push({ type: 'node', key: oldNode.key, data: oldNode })\n    }\n\n    return patches\n  }\n\n  // Constructor ===============================================================\n  //\n  constructor (context = new AudioContext(), opts = {}) {\n    // Borrowing a convetion from virtual dom libraries, the $ sign //is used to\n    // indicate \"real\" Web Audio bits, and the v- prefix is used to indicate\n    // virtual elements.\n\n    // $context is a reference to the `AudioContext` either passed in or created\n    // on construction.\n    this.$context = context\n    // A reference to the real graph of audio nodes\n    this.$nodes = {\n      $: this.$context.createGain()\n    }\n\n    // Schedule the master gain to fade in as soon as the audio context is \n    // resumed (if it was suspended) or immediately (if the context was created)\n    // in response to some user action.\n    this.$nodes.$.gain.linearRampToValueAtTime(1, this.$context.currentTime + 1)\n    this.$nodes.$.connect(this.$context.destination)\n\n    // We keep track of the prebious graph so we can perform a diff and work out\n    // what has changed between updates.\n    this.vPrev = {}\n\n    // In most modern browsers an Audio Context starts in a suspended state and\n    // requires some user interaction before it can be resumed. Still, we can\n    // attempt to resume the context ourselves in the developer passes in the\n    // `autostart` option.\n    if (opts.autostart) this.resume()\n  }\n\n  // Public Methods ============================================================\n  //\n  update (vGraph = []) {\n    // The accompanying library of virtual node functions\n    // encourages a nested tree-like approach to describing\n    // audio graphs. This isn't the easiest structure to deal\n    // with, however, so a preparation step serves to wrestle\n    // the graph into a more suitable shape.\n    const vCurr = VirtualAudioGraph.prepare(vGraph)\n\n    // A diff tracks everything that has been removed, created,\n    // and updated between updates. We perform this step so we\n    // only touch the audio nodes that need to be changed in some\n    // way.\n    const diff = VirtualAudioGraph.diff(this.vPrev, vCurr)\n\n    // Remove nodes and properties from the graph.\n    diff.removed.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._destroyNode(patch.key)\n          break\n        case 'property':\n          this._removeProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          this._disconnect(patch.key, patch.data)\n          break\n      }\n    })\n\n    // Create new nodes and add new properties to\n    // the graph.\n    diff.created.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._createNode(patch.key, patch.data)\n          break\n        case 'property':\n          this._setProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          defer(() => this._connect(patch.key, patch.data))\n          break\n      }\n    })\n\n    // Update existing nodes and properties in the\n    // graph.\n    diff.updated.forEach(patch => {\n      switch (patch.type) {\n        case 'node':\n          this._destroyNode(patch.key)\n          this._createNode(patch.key, patch.data)\n          break\n        case 'property':\n          this._setProperty(patch.key, patch.data)\n          break\n        case 'connection':\n          // Connections can't be updated\n          break\n      }\n    })\n\n    // Store the current graph for next time.\n    this.vPrev = vCurr\n  }\n\n  // A thin wrapper of the `AudioContext.suspend()` method. This\n  // bassically exists so developers don't have to reach in and\n  // touch the \"real\" audio context directly.\n  suspend () {\n    this.$nodes.$.gain.value = 0\n    this.$context.suspend()\n  }\n\n  // A thin wrapper of the `AudioContext.resume()` method. This\n  // bassically exists so developers don't have to reach in and\n  // touch the \"real\" audio context directly.\n  resume () {\n    this.$context.resume()\n    this.$nodes.$.gain.linearRampToValueAtTime(1, this.$context.currentTime + 0.1)\n  }\n\n  // Private Methods ===========================================================\n  //\n  _createNode (key, { type, properties }) {\n    let $node = null\n\n    //\n    switch (type) {\n      case 'AnalyserNode':\n        $node = this.$context.createAnalyser()\n        break\n      case 'AudioBufferSourceNode':\n        $node = this.$context.createBufferSource()\n        break\n      case 'AudioDestinationNode':\n        $node = this.$nodes.$\n        break\n      case 'BiquadFilterNode':\n        $node = this.$context.createBiquadFilter()\n        break\n      case 'ChannelMergerNode':\n        $node = this.$context.createChannelMerger()\n        break\n      case 'ChannelSplitterNode':\n        $node = this.$context.createChannelSplitter()\n        break\n      case 'ConstantSourceNode':\n        $node = this.$context.createConstantSource()\n        break\n      case 'ConvolverNode':\n        $node = this.$context.createConvolver()\n        break\n      case 'DelayNode':\n        const maxDelayTime = properties.find(({ label }) => label === 'maxDelayTime')\n        $node = this.$context.createDelay((maxDelayTime && maxDelayTime.value) || 1)\n        break\n      case 'DynamicsCompressorNode':\n        $node = this.$context.createDynamicsCompressor()\n        break\n      case 'GainNode':\n        $node = this.$context.createGain()\n        break\n      case 'IIRFilterNode':\n        const feedforward = properties.find(({ label }) => label === 'feedforward')\n        const feedback = properties.find(({ label }) => label === 'feedback')\n        $node = this.$context.createIIRFilter(\n          (feedforward && feedforward.value) || [0],\n          (feedback && feedback.value) || [1]\n        )\n        break\n      case 'MediaElementAudioSourceNode':\n        const mediaElement = properties.find(({ label }) => label === 'mediaElement')\n        $node = this.$context.createMediaElementSource(\n          document.querySelector(mediaElement.value)\n        )\n        break\n      case 'MediaStreamAudioDestinationNode':\n        $node = this.$context.createMediaStreamDestination()\n        break\n        // TODO: How should I handle creating / grabbing the media stream?\n        // case 'MediaStreamAudioSourceNode':\n        //   $node = this.$context.createMediaStreamSource(\n\n        //   )\n        //   break\n      case 'OscillatorNode':\n        $node = this.$context.createOscillator()\n        break\n      case 'PannerNode':\n        $node = this.$context.createPanner()\n        break\n      case 'StereoPannerNode':\n        $node = this.$context.createStereoPanner()\n        break\n      case 'WaveShaperNode':\n        $node = this.$context.createWaveShaper()\n        break\n      //\n      default:\n        console.warn(`Invalide node type of: ${type}. Defaulting to GainNode to avoid crashing the AudioContext.`)\n        $node = this.$context.createGain()\n    }\n\n    this.$nodes[key] = $node\n\n    //\n    properties.forEach(prop => this._setProperty(key, prop))\n\n    // Certain nodes like oscillators must be started before they will produce\n    // noise. We make the assumption that these nodes should always start\n    // immediately after they have been created, so if a `start` method exists we\n    // call it.\n    if ($node.start) $node.start()\n  }\n\n  //\n  _destroyNode (key) {\n    const $node = this.$nodes[key]\n\n    // Certain nodes like oscillators can be stopped. It probably doesn't make\n    // much of a difference calling this method, but we do just in case!\n    if ($node.stop) $node.stop()\n\n    // Calling disconnect with no arguments will disconnect this node from\n    // everything.\n    $node.disconnect()\n\n    // Finally remove the node from the graph and let the GC do its job.\n    delete this.$nodes[key]\n  }\n\n  //\n  _setProperty (key, { type, label, value }) {\n    const $node = this.$nodes[key]\n\n    switch (type) {\n      case 'NodeProperty':\n        $node[label] = value\n        break\n      case 'AudioParam':\n        $node[label].linearRampToValueAtTime(value, this.$context.currentTime + 0.05)\n        break\n      case 'ScheduledAudioParam':\n        $node[label][value.method](value.target, value.time)\n        break\n    }\n  }\n\n  //\n  _removeProperty (key, { type, label, value }) {\n    const $node = this.$nodes[key]\n\n    switch (type) {\n      case 'NodeProperty':\n        break\n      case 'AudioParam':\n        $node[label].value = $node[label].linearRampToValueAtTime($node[label].default, this.$context.currentTime + 0.05)\n        break\n      case 'ScheduledAudioParam':\n        // TODO: work out how to cancel scheduled updates\n        break\n    }\n  }\n\n  //\n  _connect (a, [b, param = null]) {\n    if (b) this.$nodes[a].connect(param ? this.$nodes[b][param] : this.$nodes[b])\n  }\n\n  //\n  _disconnect (a, [b, param = null]) {\n    if (b) this.$nodes[a].disconnect(param ? this.$nodes[b][param] : this.$nodes[b])\n  }\n}"]}