{"version":3,"sources":["utils.js","runtime/virtual-dom.js"],"names":["defer","f","setTimeout","VirtualDOM","$root","vPrev","firstChild","removeChild","node","attrs","children","vCurr","index","$el","childNodes","_replace","isText","isVirtualNode","tag","i","length","prevAttr","currAttr","setAttribute","name","value","removeAttribute","Math","max","update","isComponent","_remove","_append","document","createTextNode","createElement","attr","elem","appendChild","_create","replaceChild","remove"],"mappings":"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","file":"virtual-dom.js","sourceRoot":"../src","sourcesContent":["// Defer pushes a function to the back of the Browser's event queue. It essentially\n// tells the browser to \"do f when you next have time.\"\nexport const defer = f => setTimeout(f, 0)\n","import { defer } from '../utils'\n\nexport default class VirtualDOM {\n  // Static Methods ============================================================\n  //\n  static isText (node) {\n    return typeof node === 'string' ||\n      typeof node === 'number' ||\n      typeof node === 'boolean'\n  }\n\n  //\n  static isVirtualNode (node) {\n    return typeof node === 'object' && node.attrs && node.children\n  }\n\n  //\n  static isComponent (node) {\n    return typeof node === 'function'\n  }\n\n  // Constructor ===============================================================\n  //\n  constructor ($root) {\n    this.$root = $root\n    this.vPrev = null\n\n    // Remove any children on the root DOM node when a new VDOM is created, this\n    // ensures nothing interferes with the diffing process.\n    while (this.$root.firstChild) {\n      this.$root.removeChild(this.$root.firstChild)\n    }\n  }\n\n  // Public Methods ============================================================\n  //\n  update (vCurr, vPrev, $root, index = 0) {\n    // When update is first called it is just given the new virtual tree to diff,\n    // but it is then called recursively on each child element with the appropriate\n    // previous tree and root node. Because of this, we default to the original\n    // previous tree and the global root DOM node. We don't use the default\n    // assignment in the function arguments (like with index = 0) because I don't\n    // think you can access `this` from function arguments.\n    vPrev = vPrev || this.vPrev\n    $root = $root || this.$root\n\n    const $el = $root.childNodes[index]\n\n    // There is no previous tree.\n    if (!vPrev || !$el) {\n      this._append($root, vCurr)\n\n    // There is no new tree. This probably means we've\n    // removed a node (or the entire tree) from the previous\n    // tree so let's remove it from the dom.\n    } else if (!vCurr) {\n      $el && this._remove($el)\n\n    // There is a type mismatch between the previous and current\n    // trees. For example the old tree was an object representing\n    // a dom node, and now it is a string representing a text node.\n    } else if (typeof vPrev !== typeof vCurr) {\n      this._replace($root, $el, vCurr)\n\n    // The current nodes are the same type AND they are both text-like.\n    // This means we can do a simple equality comparison and replace\n    // them if necessary.\n    } else if (VirtualDOM.isText(vPrev) && VirtualDOM.isText(vCurr)) {\n      if (vPrev !== vCurr) {\n        this._replace($root, $el, vCurr)\n      }\n\n    // The current nodes are the same type AND they are both virtual nodes.\n    // Here we perform a more involved diff to determine what and how\n    // to update.\n    } else if (VirtualDOM.isVirtualNode(vPrev) && VirtualDOM.isVirtualNode(vCurr)) {\n      // We can safely assume if the tag has changed that the overall\n      // structure of the sub tree has changed too, and so we can\n      // replace the node and its children without performing any further\n      // diff.\n      if (vPrev.tag !== vCurr.tag) {\n        this._replace($root, $el, vCurr)\n\n      // Otherwise...\n      } else {\n        // First we diff the attributes on the node.\n        for (let i = 0; i < vPrev.attrs.length || i < vCurr.attrs.length; i++) {\n          const prevAttr = vPrev.attrs[i]\n          const currAttr = vCurr.attrs[i]\n\n          // This is somewhat ineffecient. If the order of attributes\n          // is different but both the previous and current node has\n          // the same attributes, they will be removed and then re-added.\n          if (!currAttr) {\n            $el.removeAttribute(prevAttr.name)\n          } else {\n            $el.setAttribute(currAttr.name, currAttr.value)\n          }\n        }\n      }\n\n      // Then iterate each of this node's children and recursively call\n      // the render function.\n      for (let i = 0; i < Math.max(vPrev.children.length, vCurr.children.length); i++) {\n        this.update(vCurr.children[i], vPrev.children[i], $el, i)\n      }\n\n    // Components are functions that return some virtual dom node(s), so they\n    // need to be handled differently. Currently we don't actually support\n    // components, but this is the foundation to do so.\n    } else if (VirtualDOM.isComponent(vPrev) && VirtualDOM.isComponent(vCurr)) {\n\n    }\n\n    // Update the previous tree so we can perform the right diff on subsequent\n    // calls to update.\n    this.vPrev = vCurr\n  }\n\n  // Private Methods ===========================================================\n  //\n  _create (node) {\n    if (VirtualDOM.isText(node)) {\n      return document.createTextNode(`${node}`)\n    }\n\n    // VirtualDOM.isVirtualNode performs the necessary checks to make sure the\n    // object has the necessary fields (type, attrs, children) so we can safely\n    // assume everything exists if it passes that check.\n    if (VirtualDOM.isVirtualNode(node)) {\n      // We assume the tag is valid, some checks\n      // may be useful here...\n      const $el = document.createElement(node.tag)\n\n      for (const attr of node.attrs) {\n        $el.setAttribute(attr.name, attr.value)\n      }\n\n      // Recursively create all the children\n      // of this node\n      for (const elem of node.children) {\n        $el.appendChild(this._create(elem))\n      }\n\n      return $el\n    }\n\n    // In the future we might want to handle custom omponent functions, but\n    // ight now we just return an empty node.\n    if (VirtualDOM.isComponent(node)) {\n      return document.createTextNode('')\n    }\n\n    // If some invalid object was passed in, just create a blank DOM node.\n    return document.createTextNode('')\n  }\n\n  //\n  _replace ($root, $el, node) {\n    $root.replaceChild(this._create(node), $el)\n  }\n\n  //\n  _append ($root, node) {\n    $root.appendChild(this._create(node))\n  }\n\n  //\n  _remove ($el) {\n    defer(() => $el.remove())\n  }\n}\n"]}